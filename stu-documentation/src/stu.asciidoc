= Simple Test Utils Users Documentation
SEITENBAU GmbH <stu@seitenbau.com>
v1.0, 2015-05-26
:imagesdir: images
'''

image::seitenbau-110px.png[SEITENBAU Logo]

== Overview

TODO general projekt description

link:changelog.asciidoc[Changelog]

== Common STU features
In this chapter common functionality of STU is described. The presented features are not related to
database testing only, but can be used for general test setup. 

=== TestConfiguration
To provide a unique configuration for tests for each developer, the +TestConfiguration+ class should be used.
With help of the +TestConfiguration+ you can store configuration values to a static or non-static class dependent
on the current environment.

==== Setting up TestConfigurations
An example for a static configuration:
[source,java]
----
public class TestConfig
{
  @StoredProperty(key = "fs.root")
  public static String FS_CONNECTION;
  static
  {
    TestConfiguration.load(TestConfig.class);
  }
}
----
In that case the variable +FS_CONNECTION+ is initialized with the property value for +fs.root+.

===== Determine the environemnt
Configurations are loaded via the directory +src/test/resources/test/*+ in the order logged to the console:

* +default-test.properties+
* +<your-username>.properties+
* +<your-compuername>.properties+

The data is loaded in the order stated above. Later loaded data replaces already loaded data.
The notation +${varname}+ can be used to keep parts of values exchangeable.

In addition a specific environment can be determined by setting the environment variable +SB_CONFIG_TARGET+.
In that case the default-properties and afterwards the specific configuration is loaded.

==== Special variables
Here are some special variables that are initialized by default:
[cols="2", options="header"]
|===
|Variable
|Description

|+_host.ip+
|Ip of the computer.

|+_host.name+
|Host name of the computer.

|+_host.dns+
|DNS name of the computer.

|+_username+
|The name of the current user. Works with Windows and Ubuntu/Debian.

|+_host.ipV4+
|IP v4 address of the computer.

|+_host.ipV6+
|IP v6 address of the computer.
|===

==== Special configuration preferences
[cols="2", options="header"]
|===
|Key
|Description

|+_debug+
|Determines if the loaded configuration properties are logged to the console.

|+_debug.loglevel+
|Loglevel of the +TestLogger+ of STU. Allowed levels are: +TRACE+, +DEBUG+, +INFO+, +WARN+, +ERROR+ and +FATAL+.
|===

==== Examples for supported notations
The +TestConfiguration+ supports the following data types:

* +Boolean+
* +Enum+
* +Integer+
* +Map+
* +String+

[source,java]
----
public class TestConfig
{
  @StoredProperty(key="a-default-value")
  public static String STRING_VALUE;
   
  @StoredProperty(key="aNumber")
  public static Integer NUMBER;
   
  @StoredProperty(key="aMap")
  public static Map<String, String> MAP;
   
  public enum State {START,STOP}
   
  @StoredProperty(key="anEnum")
  public static State STATUS;
   
  static
  {
    TestConfiguration.load(TestConfig.class);
  }
}
----

The corresponding properties file format:

[source,text]
----
# Variable that is replaced with assigned value, but not referenced in TestConfig.
var=someValue
 
# A String. The second var expression is escaped and therefore not replaced. 
a-default-value= The default ${var} \\${var}
 
# A number. Read as Integer if specified in corresponding TestConfig class.
aNumber=42
 
# A Map<String,String>
aMap[Martin]= ${var}: Fowler
aMap[Max]= ${var}: Power \\${var}
 
# A mapped ENUM
anEnum=START
----

=== STU Annotations for Tests
The STU project provides annotations that makes the maintenance of tests easier and offers
the possibility to determine the execution of (single) tests by annotations, dependent on configuration
values. 

==== Basic concepts
If tests failing, the cause should be annotated directly at the failing test. Therefore the annotation
+@TestIssue+ is provided. A String can be passed as parameter to the annotation. The annotation supports
the minimalistic +TicketDSL+. The annotation is recorded by the Test-State recorder by default.
In addition a similar concept is provided as +RequirementDSL+. The purpose for the requirments annotation is
to disable tests in a specific environment. 

==== +TickeDSL+

Extended Backus-Naur Form of the +TicketDSL+
[cols="2", options="header"]
|===
|Token
|EBNF

|+TickeDSL+
|[+CONDITION+] +TICKET_ID+

|+CONDITION+
|+STATE+ ":"

|+STATE+
|"open" {brvbar} "fixed" {brvbar} "ignored"

|+TICKET_ID+
|RegEx = [A-Za-z0-9_-]*
|===

Supported states are:

* +open+ : The ticket is new or in process. The test is exected to fail.
* +fixed+ : The ticket is closed. The test is expected to success.
* +ignored+ : The related ticket is referenced. The expected behavior is the same as +fixed+. 

[cols="2", options="header"]
|===
|Example
|Description

|"STUTESTING-123"
|open ticket (default, no +STATE+ provided)

|"open:STUTESTING-123"
|open ticket

|"fixed:STUTESTING-123"
|closed ticket
|===

==== Example use of +TicketDSL+

To make it easy to find Tickets inside an IDE, it is recommended to define all ticket ids as constants inside
an interface.

[source,java]
----
public interface ProjectTickets {
  /** SampleService Impl, Call of service method returns null */
  String SBTESTING_123 = "SBTESTING-123";
}
----

Inside a test only the constants should be referenced.

[source,java]
----
@Test
@TestIssue(ProjectTickets.SBTESTING_123)
public void test_0101_ValidCall() throws Throwable {
    ...
}
----

==== +RequirementDSL+

Extended Backus-Naur Form of the +RequirementDSL+
[cols="2", options="header"]
|===
|Token
|EBNF

|+RequirementDSL+
|[+CONDITION+] +REQUIRMENT+

|+CONDITION+
|+STATE+ ":"

|+STATE+
|"impl" {brvbar} "notimpl" {brvbar} "implemented" {brvbar} "notimplemented" {brvbar} "custom"

|+REQUIREMENT+
|any non whitespace characters
|===

Supported states are:

* +impl/implemented+ : The requirement is implemented. The test should be executed.
* +notimpl/notimplemented+ : The requirement is not implemented yet. The test should not be executed.
* +custom+ : Marked as first-hand +FeatureDetector+. See +FeatureDetector+ explanation.

[cols="2", options="header"]
|===
|Example
|Description

|"MYSQL_DB_3"
|Feature MYSQL_DB is not implemented yet (default, if no +STATE+ provided).

|"notimpl:MYSQL_DB_3"
|Feature MYSQL_DB_3 is not implemented yet.

|"impl:MYSQL_DB_3"
|Feature MYSQL_DB_3 is implemented.

|"custom:com.seitenbau.stu.dsl.requirement.RequirementDslTest.ActiveDetector"
|The +FeatureDetector+ is used to determine if the feature is active.
|===

==== Example for a +FeatureDetector+
The +TestPropertyIs+ +FeatureDetector+ validates if a given test configuration value is set:

[source,text]
----
custom:com.seitenbau.stu.dsl.requirement.TestPropertyIs:key=rainer
--> Verifies that the TestConfiguration value for parameter "key" equals "rainer"

custom:com.seitenbau.stu.dsl.requirement.TestPropertyIs:!key=rainer
--> Verifies that the TestConfiguration value for parameter "key" is not equal to "rainer"
----

==== Example use of +RequirmentDSL+

The +@Requires+ annotation can be used to check if a +TestConfig+ value is set for example.
Only if the particular value is set, the test is executed.

[source,java]
----
@RunWith(SBTestRunner.class)
public class RequiresTest
{
   
  @Rule
  public RequiresRule req = new RequiresRule();
   
  @Test
  @Requires(TestRequirement.SOLAR)
  public void sonar() throws Exception
  {
    fail("Requires sonar server");
  }
   
}
 
public class TestRequirement
{
  public static final String SOLAR = "custom:com.seitenbau.stu.dsl.requirement.TestPropertyIs:testinstance.solar.available=true";
}
----

A corresponding +TestConfig+ class :

[source,java]
@StoredProperty(key = "testinstance.solar.available", defaultValue="false")
public static boolean requiresSolar;
----

=== JUnitRules







== Generating test data
In this section the generating of test data with STU is described. The generation of test data can be splitted into five steps:

. Extract and generate the database model
. Customize the database model
. Generate the test data
. Customize the test data
. Import the test data into the database

=== Extract and generate the database model
If the database model is defined in a database, it can be extracted with the STU framework. 
For this you can use the +ModelGeneratorUI+ in +com.seitenbau.stu.database.modelgenerator+ in the project +stu-database+. 

=== Customize the database model
The following sections describe the most important functions are to create and customize a database model described.
The full example can be found in the project +stu-examples+ in the file +src/dataset-model/java/model/BookDatabaseModel.java+.

==== Structure of a model class
All model classes must be derived from +DatabaseModel+.
In the constructor the methods +database()+ and +packageName()+ defines the name of the database and the package path the generated test data model classes will get.
With the methods +enableTableModelClassesGeneration()+ and +disbaleTableDSLGeneration()+ can be selected whether the model classes are generated and 
whether the generation of the table DSL to be deactivated.
The method +infinity()+ defines the number of records that will be generated.
This is an example of a database model:
[source,java]
----
package model;

import com.seitenbau.stu.database.generator.DataType;
import com.seitenbau.stu.database.generator.DatabaseModel;
import com.seitenbau.stu.database.generator.TableBuilder;

public class BookDatabaseModel extends DatabaseModel {
		public BookDatabaseModel() {
			database("BookDatabase");
			packageName("com.seitenbau.stu.bookdatabase.model");
			enableTableModelClassesGeneration();
			//disableTableDSLGeneration();
			infinite(4);
	}
}
----

==== Add a table to the database model

[source,java]
----
TableBuilder book = table("book");
book.build();
----

===== Add a column to the table
With the method +column()+ a column can be added to the table. The first parameter is name of the column and the second parameter is the datatype.

[source,java]
----
book.column("name", DataType.VARCHAR))
----

===== Add a column with a primary key attribute to the table
The methods +defaultIdentifier()+  and +autoInvokeNext()+ define, that a column is defined as the primary key of a table. 

[source,java]
----
book.column("id", DataType.BIGINT).defaultIdentifier().autoInvokeNext()
----

==== Add a foreign key reference to a column
The column of a table can contain a foreign key reference to another table. 
In this example the methods +foreign+ and +ref+ are used to add the reference to a column.
With the method +multiplicity+ the multiplicity is defined.

[source,java]
----
book.foreign(publisher.ref("id")).multiplicity("0..*")
----

===== Add a data generator to columns
With the method +generator+ a generator is linked to a column.

[source,java]
----
book.column("price", DataType.Double).generator(new DoubleGenerator())
----

The following sections describe different generators are presented:

====== IntegerGenerator
The +IntegerGenerator+ any integer value can be generated. Optionally, with two parameters, the lower and upper limit can be specified.

[source,java]
----
IntegerGenerator integerGenerator = new IntegerGenerator();
IntegerGenerator integerGenerator = new IntegerGenerator(1900, 2015);
----

Similar generators, such as the +DoubleGenerator+, +LongGenerator+, etc., can be used analogously.

====== DataGenerator







==== Create a associative table
[source,java]
----
TableBuilder book = table("book");
book.column("id", DataType.BIGINT).defaultIdentifier().autoInvokeNext()
book.build();

TableBuilder author = table("author"); 
author.column("id", DataType.BIGINT).defaultIdentifier().autoInvokeNext()
author.build();

associativeTable("book_author")
	.column("book_id", DataType.BIGINT).reference.foreign(book)
	.multiplicity("0..*")
	.column("author_id", DataType.BIGINT).reference.foreign(author)
	.multiplicity("1..*")
	.build();
----

==== Add constraints to the database model
Constraints can be add to the database model with the method +constraint()+. 
First, the two types are described by sources constraint. Subsequently, the different types of constraints are presented.

===== Constraint parameters
There are two possible types of parameters:
* Constant values
* Source names

====== Constant values
[source,java]
---- 
IntValue intValue = new IntValue(11);
----


====== Source names
There are three supported types of source names:

* Source is one cell
* Source is one column
* Source is one table


*A cell*
[source,java]
---- 
"author.lastlogin"
----

*A column*
[source,java]
---- 
"author.username"
----

*A table*
[source,java]
---- 
"author"
----

===== UniqueConstraint
The unique constraint specify one column to be unique. Normally the constructors is called with the source column, but it is also possible to specify more than one column. 

[source]
---- 
new UniqueConstraint(String... sourceNames);
----

*Parameters:*
[horizontal]
Source:: The name of the source column with formatting "table.column".

[source,java]
---- 
constraint(new UniqueConstraint("author.username");
constraint(new UniqueConstraint("author.email1", "author.email2");
----

===== RangeConstraint
With the range constraint you can define, that the generated value of the column is between the two values. The first parameter of the constructor has to be always the source column. The second and third parameter define the lower and upper limit. The lower and upper limits can be either constant values or source name.

[listing]
---- 
a >= b && a <= c
----

[source]
---- 
new RangeConstraint(a, b, c);
----

*Parameters:*
[horizontal]
a:: The name of the source column with formatting "table.column".
b:: The name of the source with formatting "table.column" *or* a constant value.
c:: The name of the source with formatting "table.column" *or* a constant value.


*Examples:*
[source,java]
---- 
constraint(new RangeConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new RangeConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new RangeConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----

===== DomainConstraint
The domain constraint... 

----
a is valid with b
new DomainConstraint(a, b);
----

[source,java]
---- 
constraint(new DomainConstraint("author.postalCode", "author.city"));
constraint(new DomainConstraint("author.postalCode", "author.street"));
constraint(new DomainConstraint("author.streetNumber", "author.street"));
constraint(new DomainConstraint("author.firstName", "author.gender"));
----

===== LogicalConstraint
A logical constraint has always two parameters. The choice of the operator is done by the choice of the subclass. 

[listing]
---- 
a operator b
----

[source]
---- 
new LogicalConstraint(a, b);
----


*Constructors:*
[source,java]
---- 
LogicalConstraint(String sourceName1, String sourceName2)
LogicalConstraint(String sourceName, Value<?> value)
LogicalConstraint(Value<?> value, String sourceName)
----

*Parameters:*
[horizontal]
sourceName:: The name of the source column with formatting "table.column".
value::  A constant value.

The following sections describe the supported logical constraints.

====== EqualConstraint
[listing]
---- 
a == b
----

*Examples:*
[source,java]
---- 
constraint(new EqualConstraint("author.country", "adresse.country"));
constraint(new EqualConstraint("author.online", new IntValue(0)));
----

====== NotEqualConstraint
[listing]
---- 
a != b
----

*Examples:*
[source,java]
----
constraint(new NotEqualConstraint("author.firstname", "Test"));
constraint(new NotEqualConstraint("author.firstname1", "author.firstname2"));
----

====== GreaterConstraint
[listing]
---- 
a > b
----

*Examples:*
[source,java]
----
constraint(new GreaterConstraint("author.yearOfBirth", new IntValue(1900)));
constraint(new GreaterConstraint("author.registrationYear", "author.yearOfBirth"));
constraint(new GreaterConstraint(new IntValue(2015), "author.yearOfBirth"));
----

====== GreaterEqualConstraint
[listing]
---- 
a >= b
----

*Examples:*
[source,java]
----
constraint(new GreaterEqualConstraint("author.yearOfBirth", new IntValue(1900)));
constraint(new GreaterEqualConstraint("author.registrationYear", "author.yearOfBirth"));
constraint(new GreaterEqualConstraint(new IntValue(2015), "author.registrationYear"));
----

====== LowerConstraint
[listing]
---- 
a < b
----

*Examples:*
[source,java]
----
constraint(new LowerConstraint(new IntValue(1900), "author.yearOfBirth"));
constraint(new LowerConstraint("author.yearOfBirth", "author.registrationYear"));
constraint(new LowerConstraint("author.registrationYear", new IntValue(2015)));
----

====== LowerEqualConstraint
[listing]
---- 
a <= b
----

*Examples:*
[source,java]
----
constraint(new LowerEqualConstraint(new IntValue(1900), "author.yearOfBirth"));
constraint(new LowerEqualConstraint("author.yearOfBirth", "author.registrationYear"));
constraint(new LowerEqualConstraint("author.registrationYear", new IntValue(2015)));
----


===== FunctionalConstraint
A functional constraint has always three parameters. A maximum of 2 parameters may be constant values.

[listing]
----
a function b = c
----

*Parameters:*
[horizontal]
a:: The name of the source with formatting "table.column" *or* a constant value.
b:: The name of the source with formatting "table.column" *or* a constant value.
c:: The name of the source with formatting "table.column" *or* a constant value.

*Constructors*
[source,java]
---- 
FunctionalConstraint(String sourceName1, String sourceName2, String resultSource)
FunctionalConstraint(String sourceName1, String sourceName2, Value<?> value)
FunctionalConstraint(String sourceName1, Value<?> value, String resultSource)
FunctionalConstraint(Value<?> value, String sourceName1, String resultSource)
FunctionalConstraint(String sourceName1, Value<?> value1, Value<?> value2)
FunctionalConstraint(Value<?> value1, String sourceName1, Value<?> value2)
FunctionalConstraint(Value<?> value1, Value<?> value2, String resultSource)
----

====== AddConstraint
[listing]
---- 
a + b = c
----

*Examples:*
[source,java]
---- 
constraint(new AddConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new AddConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new AddConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----


====== SubConstraint
[listing]
---- 
a - b = c
----

*Examples:*
[source,java]
---- 
constraint(new SubConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new SubConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new SubConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----


====== MultiConstraint
[listing]
---- 
a * b = c
----

*Examples:*
[source,java]
---- 
constraint(new MultiConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new MultiConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new MultiConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----

====== DivConstraint
[listing]
---- 
a / b = c
----

*Examples:*
[source,java]
---- 
constraint(new DivConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new DivConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new DivConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----

====== PowConstraint
[listing]
---- 
a ^ b = c
----


*Examples:*
[source,java]
---- 
constraint(new PowConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new PowConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new PowConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----

====== ModConstraint
[listing]
---- 
a % b = c
----

*Examples:*
[source,java]
---- 
constraint(new ModConstraint("author.yearOfBirth", new IntValue(1900), new IntValue(2015)));  
constraint(new ModConstraint("author.registrationYear", "author.yearOfBirth", new IntValue(2015)));
constraint(new ModConstraint("author.registrationYear", "author.yearOfBirth", "author.lastlogin"));
----

===== AggregateConstraint

====== SumConstraint
[listing]
---- 
a = Sum(b)
----

*Parameters:*
[horizontal]
a:: The name of the source with formatting "table.column".
b:: The name of the source with formatting "table.column".

*Examples:*
[source,java]
---- 
constraint(new SumConstraint("author.shoppingCartSum", "shoppingCartArticle.price"));
----

====== ProductConstraint
[listing]
---- 
a = Product(b)
----

*Parameters:*
[horizontal]
a:: The name of the source with formatting "table.column".
b:: The name of the source with formatting "table.column".


*Examples:*
[source,java]
---- 
constraint(new ProductConstraint("author.shoppingCartProduct", "shoppingCartArticle.price"));
----

====== LengthConstraint
[listing]
---- 
a = Length(b)
----

*Parameters:*
[horizontal]
a:: The name of the source with formatting "table.column".
b:: The name of the source with formatting "table.column".


*Examples:*
[source,java]
---- 
constraint(new LengthConstraint("author.shoppingCartProduct", "shoppingCartArticle.price"));
----

====== CountConstraint
[listing]
---- 
a = Count(b)
----

*Parameters:*
[horizontal]
a:: The name of the source with formatting "table.column".
b:: The name of the source with formatting "table".


*Examples:*
[source,java]
---- 
constraint(new CountConstraint("author.shoppingCartCount", "shoppingCartArticle"));
----

=== Generate the test data
Run the generator to generate the dsl...

[source,java]
----
public class BockDatabaseDataGenerator
{
  public static void main(String[] args) throws Exception
  {
	TestConfiguration.load(Object.class);
	  
    final DatabaseModel model = new BookDatabaseModel();

    final DataGenerator generator = new DataGenerator(model);

    final Entities entities = generator.generate("book");

    STUTableOutput output = new STUTableOutput();
    final String generatedDSL = output.create(entities);
    System.out.println(generatedDSL);

    System.out.println("-----------------------------");
    entities.printStats();
    System.out.println();

    System.out.println("Verification Loop Iterations: " + entities.getLoopCount() + "\t");
  }
}
----


=== Customize the test data
This step is optional. Here you can change the data values directly in the DSL.


=== Import the test data into the database
First you have to generate the classes...after this you can import the generate the file...


== Implement new features to the framework
If you can't find the domain data type for the domain data generator or you need a specific value generator or a another constraint type, you have the possible the implement these features.

=== Add a new data source to the domain generator


=== Create a new value generator
All value generator classes are subclasses of the class ValueGenerator. You have to implement the method newValue().

=== Create a new constraint type
All constraint classes are  subclasses of the class ConstraintBase. You have to implement the methods isValid(), getCopyInstance(), getHints() and the constructors you want to support.

=== Generate test

== Testing databases 
Here comes information for the database classes. 

=== Modeling of databases

=== Migration of generated DataSets

=== Connecting to a (Test-)Database

=== Verify Database state

== Example implementation
Here comes information about the example implementation.
