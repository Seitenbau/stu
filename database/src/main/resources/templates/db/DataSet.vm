#set($filename = ${model.names.dataSetClass} )
#set($package  = ${model.package} )
#set($clsDataSet = ${model.names.dataSetClass})
#if( $package && $package.length() != 0 )
package ${package};
#end
##
## ************************************************************
## *                   Begin of File                          *
## ************************************************************
##
import com.seitenbau.testing.dbunit.util.DbCompare;
import com.seitenbau.testing.dbunit.dsl.DataSetIdentificator;
import com.seitenbau.testing.dbunit.dsl.DataSetRegistry;
import com.seitenbau.testing.util.DateUtil;
import com.seitenbau.testing.util.date.DateBuilder;
import com.seitenbau.testing.dbunit.extend.DatasetIdGenerator;
import com.seitenbau.testing.dbunit.extend.DbUnitDatasetFactory;
import com.seitenbau.testing.dbunit.extend.impl.DefaultIdGenerator;
import org.dbunit.dataset.DefaultDataSet;
import org.dbunit.dataset.IDataSet;
import java.util.Date;

#foreach( $table in $model.tables )
#set($rowbuilder   = ${model.names.getRowBuilderClass($table)} )
#set($tableClass   = ${model.names.getTableClass($table)} )
import ${package}.${tableClass}.${rowbuilder};
#end

/*********************************************************
  {@link DbUnitDatasetFactory} factory to create in-memory 
  {@link IDataSet} for your Database. 
  </br>
  This class is generated by ${model.caller}
**********************************************************/
public abstract class ${clsDataSet} implements DbUnitDatasetFactory, DataSetIdentificator
{
  /** 
   * Now at time of creation, This is 'fixed' so the time can be used when
   * adding multiple lines, it's still kind of 'now' but can be predicted.
   */
  // TODO NM rename this variable
  DateBuilder _jetzt = DateUtil.datum();
  
  /**
   * Reference to an {@link DatasetIdGenerator}. Used to set IDs.
   * See Flags when adding an column in your model to create nextId()
   * methods.
   */
  DatasetIdGenerator _idGenerator;

  // All Tables as instances ( see {@link #prepareTables} for init code ) 
#foreach( $table in $model.tables )
#set( $tableClass = ${model.names.getTableClass($table)} )
  public ${tableClass} ${model.names.getTableVariable($table)} = new ${tableClass}();
#end

  /**
   * Create a new instance of this DbUnitDatasetFactory. This
   * will create all tables and invoke the template methods to
   * modify the DataSet content.<br/> 
   * To inject your own data use the initDataSet() method.
   */
  public ${clsDataSet}() 
  {
    DataSetIdentificator lastDataSet = DataSetRegistry.use(this);
    prepareTables();
    beforeInitDataSet();
    initDataSet();
    afterInitDataSet();
    DataSetRegistry.use(lastDataSet);
  }
  
  /**
   * Create the actual DBUnit IDataSet.
   */
  public IDataSet createDBUnitDataSet()
  {
    beforeDataSetCreation();
#set($tabs = "")
#if( $model.createException )
#set($tabs = "  ")
    try {
#end
    ${tabs}DefaultDataSet dataSet = new DefaultDataSet();
#foreach( $table in $model.tables )
    ${tabs}dataSet.addTable(${model.names.getTableVariable($table)});
    ${tabs}table_${table.javaName}.resetIterator();
#end
    ${tabs}afterDataSetCreation(dataSet);
    ${tabs}return finalModify( dataSet );
#if( $model.createException )
    } catch($model.createException e) {
      throw new RuntimeException(e);
    } 
#end
  }
  
  /**
   * Injection point. Last processing template method to modify the resulting 
   * Dataset created by createDBUnitDataSet(). 
   * You should really know what you're doing!
   *
   * @param dataSet
   * @return
   */
  protected DefaultDataSet finalModify(DefaultDataSet dataSet)
  {
    return dataSet;
  }
  
  /**
   * Template Method, get's called after createDBUnitDataSet() method
   * Use this only if really needed.
   */
  protected void afterDataSetCreation(DefaultDataSet dataSet) 
#if( $model.createException ) 
      throws $model.createException
#end
  {
  }

  /**
   * Template Method, get's called before createDBUnitDataSet() method.
   * Use this only if really needed. 
   */
  protected void beforeDataSetCreation()
  {
  }
  
  /**
   * Template Method, got called after the initDataSet() method
   */
  protected void afterInitDataSet()
  {
  }

  /**
   * Inner method to prepare the table instances.
   * Do not overwrite.
   */
  protected void prepareTables()
  {
#foreach( $table in $model.tables )
    ${model.names.getTableVariable($table)}.setDataset(this);
#end
  }
  
  /**
   * Template Method, got called before the initDataSet() method
   */
  protected void beforeInitDataSet()
  {
  }

  /**
   * Initialize the content of your Dataset here.
   */
  abstract protected void initDataSet();
  
  /** 
   * Compare the given Date to be 'equal' around (+-15s). 
   */
  public Date around(DateBuilder datum) 
  {
    return DbCompare.warp(datum);
  }

  /** 
   * <p>
   * Create org get the 'current' timestamp as DateBuilder. 
   * Subsequent calls will give you the same builder and TIME again!
   * This allows you to use the same "now" for the whole dataset.<br>
   * <b>!!But be aware that this will be a fixed now, of the time where the 
   * Factory was created!!</b> 
   * </p>
   */
  public DateBuilder jetzt()
  {
    return _jetzt;
  }
  
  /**
   * Change the used id generator
   **/
  public void setIdGenerator(DatasetIdGenerator gen)
  {
    _idGenerator = gen;
  }
  
  /**
   * Return the current active {@link DatasetIdGenerator}
   */
  public DatasetIdGenerator getIdGenerator()
  {
    if(_idGenerator == null) 
    {
      _idGenerator = new DefaultIdGenerator();
    }
    return _idGenerator;
  }
  
  
  /** run the given modifiers on this dataset */
  public ${clsDataSet} modify(${model.names.dataSetModifierClass} ... modifiers) 
  {
    // TODO NM/CB think about this statement: Can modifiers ever be null? oO
    if (modifiers == null) 
    {
      return this;
    }
    for (${model.names.dataSetModifierClass} modifier : modifiers) 
    {
      modifier.modify(this);
    }
    return this;
  }
  
  /**
   * Interface for the double dispatch. Used by {@link #modify} to
   * extract creation logic into an external strategy.
   */ 
  public interface ${model.names.dataSetModifierClass}
  {
    void modify(${clsDataSet} dataset);
  }
  
  /* ************************************************************ */
  /* *             convenient add(*) methods                    * */
  /* ************************************************************ */
#foreach( $table in $model.tables )
#set($rowbuilder   = ${model.names.getRowBuilderClass($table)} )
#set($rowmodel     = ${model.names.getRowModelClass($table)} )

  /** 
   * Adds the given row into the Table '${table.name}'
   */
  public $rowbuilder add(${rowbuilder} row) 
  {
    return table_${table.javaName}.insertRow(row);
  }
#if( ${model.isModelClassGeneration()} )
  
  /** 
   * Adds the given row into the Table '${table.name}'
   */
  public $rowbuilder add(${rowmodel} row) 
  {
    return table_${table.javaName}.insertRow(row);
  }
#end
  /**
   * ! work in progress !
   * create a new Model of the Type ${rowmodel} with 
   * the same IdGenerator that this Dataset  
   */
  /*
  public ${rowmodel} create${table.javaName}() 
  {
    ${rowmodel} model = new ${rowmodel}();
    model.setIdGenerator(getIdGenerator());
#foreach( $column in $table.columns )
#if( $column.isNextValueMethodGenerated() )
    model.next${column.javaName}();
#end
#end
    return model;
  }
  */
#end

  @Override
  public String getDataSetClassName()
  {
    return "${model.package}.${model.name}";
  }

  @Override
  public Object getDataSet()
  {
    return this;
  } 
 
}
